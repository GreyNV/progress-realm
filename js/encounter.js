// Agents: Encounters drive the adventure portion of the game. Encounters are
// generated by EncounterGenerator and resolved by AdventureEngine. Loot and
// progression are handled here before flowing back into State and Inventory.
class Encounter {
    constructor(data) {
        this.id = data.id;
        this.name = data.name;
        this.description = data.description || '';
        this.image = data.image || '';
        this.rarity = data.rarity || 'common';
        this.category = data.category || 'strength';
        this.baseDuration = data.baseDuration || 5;
        this.minLevel = data.minLevel || 0;
        this.storyLevel = data.storyLevel;
        this.resourceConsumption = data.resourceConsumption || {};
        this.items = data.items || null;
        this.loot = data.loot || {};
    }

    getDuration() {
        const stat = Math.max(getStatValue(this.category) || 0, 1);
        const level = Math.max(EncounterGenerator.level, 1);
        const minDuration = this.baseDuration * EncounterGenerator.baseDurationScale;
        const calculated = level / stat;
        return Math.max(minDuration, calculated);
    }

    getLootChance() {
        const base = EncounterGenerator.lootBaseByCategory[this.category] || 0;
        const stat = getStatValue(this.category) || 0;
        return base + stat * EncounterGenerator.lootBonusPerStat;
    }

    getLootMultiplier() {
        const stat = getStatValue(this.category) || 0;
        return 1 + stat * EncounterGenerator.lootYieldBonusPerStat;
    }

    getResourceCost() {
        const scale =
            1 + EncounterGenerator.level * EncounterGenerator.costScalePerLevel;
        const cost = {};
        for (const k in this.resourceConsumption) {
            cost[k] = this.resourceConsumption[k] * scale;
        }
        return cost;
    }
}

const EncounterGenerator = {
    encounters: [],
    container: null,
    level: 0,
    milestones: [],
    rarityWeights: {
        common: 1,
        rare: 0.5,
        epic: 0.2,
        legendary: 0.1,
        story: 0.05,
    },
    lootBaseByCategory: {
        strength: 0.02,
        intelligence: 0.02,
        creativity: 0.02,
    },
    lootBonusPerStat: 0.001, // +0.1% loot chance per stat point
    lootYieldBonusPerStat: 0.02, // +2% loot amount per stat point
    durationModPerStat: 0.02, // -2% duration per stat point
    costScalePerLevel: 0.1, // +10% cost per encounter level
    baseDurationScale: 1, // multiplier for encounter minimum duration

    async load() {
        try {
            const res = await fetch('data/encounters.json');
            const json = await res.json();
            this.encounters = json.map(e => new Encounter(e));
        } catch (e) {
            console.error('Failed to load encounters', e);
            this.encounters = [];
        }

        try {
            const res = await fetch('data/locations.json');
            const json = await res.json();
            this.milestones = json;
        } catch (e) {
            console.error('Failed to load locations', e);
            this.milestones = [{ level: 0, name: 'Unknown' }];
        }
    },

    updateName() {
        const milestone = this.milestones
            .slice()
            .reverse()
            .find(m => this.level >= m.level);
        const name = milestone ? milestone.name : this.milestones[0].name;
        const el = document.getElementById('encounter-location');
        if (el) {
            el.textContent = `${name} (Level ${this.level})`;
        }
        this.updateProgressBar();
    },

    updateProgressBar() {
        const bar = document.getElementById('encounter-level-progress');
        if (bar) {
            bar.max = 10;
            bar.value = Math.min(State.encounterStreak || 0, 10);
        }
    },

    incrementLevel() {
        this.level += 1;
        State.encounterLevel = this.level;
        this.updateName();
        this.updateProgressBar();
    },

    decrementLevel() {
        if (this.level > 0) {
            this.level -= 1;
            State.encounterLevel = this.level;
            this.updateName();
            this.updateProgressBar();
        }
    },

    resetProgress() {
        this.populateSlots();
        State.encounterStreak = 0;
        this.updateProgressBar();
        if (typeof AdventureEngine !== 'undefined') {
            AdventureEngine.startSlot(0);
        }
    },

    init() {
        this.container = document.getElementById('adventure-slots');
        if (!this.container) return;
        this.level = State.encounterLevel || 0;
        this.updateName();
        this.updateProgressBar();
        this.populateSlots();
    },

    getRecoverEncounter() {
        return this.encounters.find(e => e.id === 'recover') || null;
    },

    randomEncounter() {
        if (!this.encounters.length) return null;
        const story = this.encounters.find(e => {
            if (e.rarity !== 'story') return false;
            if (e.storyLevel === undefined) return false;
            if (this.level < e.storyLevel) return false;
            if (e.id === 'banditsAmbush' && State.banditsAmbushSeen) return false;
            return true;
        });
        if (story) return story;

        const pool = this.encounters.filter(e => {
            if ((e.minLevel || 0) > this.level) return false;
            // Recover is only triggered after retreats and should not be random
            if (e.id === 'recover') return false;
            return true;
        });
        if (!pool.length) return null;
        const weights = pool.map(e => this.rarityWeights[e.rarity] || 1);
        return Utils.weightedRandomChoice(pool, weights);
    },

    populateSlots() {
        for (let i = 0; i < State.adventureSlots.length; i++) {
            State.adventureSlots[i].encounter = null;
            State.adventureSlots[i].duration = 1;
            State.adventureSlots[i].progress = 0;
            State.adventureSlots[i].active = false;
            updateAdventureSlotUI(i);
        }
    },

    resolve(encounter) {
        for (const [id, qty] of Object.entries(encounter.loot || {})) {
            const item = ItemGenerator.itemList.find(i => i.id === id);
            if (!item) continue;
            const mult = encounter.getLootMultiplier();
            const total = Math.max(0, Math.floor(qty * mult));
            for (let i = 0; i < total; i++) {
                Inventory.add(item);
            }
        }

        if (encounter.id === 'banditsAmbush') {
            const msg = Lang.log('banditsAmbushWin') ||
                'You survived the bandits ambush and claimed your reward.';
            Log.add(msg);
            if (!State.banditsAmbushSeen) {
                Story.show(
                    Lang.story('banditsAmbushVictory') || 'Bruised but victorious, you gather loot from the fallen bandits.',
                    '',
                    () => {
                        State.banditsAmbushSeen = true;
                        SaveSystem.save();
                    }
                );
            }
            return;
        }
        const chance = encounter.getLootChance();
        if (Math.random() < chance) {
            const item = ItemGenerator.generateFromEncounter(encounter);
            if (item) {
                const itemHTML = `<span class="rarity-${item.rarity}"><b>${item.name}</b></span>`;
                const encHTML = `<span class="rarity-${encounter.rarity}"><b>${encounter.name}</b></span>`;
                const msg = Lang.log('foundItem', { item: itemHTML, encounter: encHTML }) ||
                    `You found ${itemHTML} during ${encHTML}!`;
                Log.add(msg);
                Inventory.add(item);
            }
        }
    }
};
